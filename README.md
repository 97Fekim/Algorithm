# Algorithm
🗝<br>
## BOJ 풀이
- [코드로 이동](https://github.com/97Fekim/Algorithm/tree/master/src/BAEKJOON)
## LeetCode 풀이
- [문제풀이](https://velog.io/@16fekim?tag=leetcode)
## [자바(Java) 알고리즘 문제풀이 : 코딩테스트 대비] ,인프런
- [코드로 이동](https://github.com/97Fekim/Algorithm/tree/master/src/Inflearn)
- [강의 문제 풀이](https://github.com/97Fekim/Algorithm/blob/master/Inflearn%20Algorithm%20Basic.md)
- [문제 유형별 키워드](https://velog.io/@16fekim/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Java%EB%A1%9C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A4%80%EB%B9%84)
## 마구잡이 정리 노트
- 정렬된 배열 순회시 <strong>이분 검색(Binary Search)</strong> 고려하기
- 무언가 연결해야 한다면 <strong>리스트</strong> 고려하기
- 쌍을 맞춰야 하는 연산자, 수식이 있다면 <strong>스택</strong> 고려하기
- 정렬된 배열을 다룬다면 <strong>투포인터</strong> 고려하기
- 배열에서 특정 구간씩 다룰때, <strong>슬라이딩 윈도우</strong> 고려하기
- 배열에서 범위가 어느정도 정해진 정답을 구해야 할때, <strong>결정 알고리즘</strong> 고려하기
- 소수와 관련된 문제라면 <strong>에라토스테네스의 체</strong> 이용하기
- 배열의 중복을 제거해야 하는 문제라면 <strong>HashMap 이나 HashSet</strong> 이용하기
- 최소공배수와 관련된 문제라면 <strong>GCD(Greate Common Devisior)</strong> 이용하기
- 불필요하게 반복 호출되는 재귀 (예를들면 피보나치, 조합, 등)는 <strong>메모이제이션</strong>을 통해 시간복잡도를 줄일 수 있다.
- 2차원, 3차원 배열로 주어진 그래프의 탐색 문제는 <strong>거리 정보를 담은 dx, dy 배열</strong> 이용하기
- BFS, DFS 구현시 check 배열의 범위를 초과해 발생하는 NullPointerException 주의. 
- 여러 개의 순서쌍이 주어지는 문제라면, 한 종류를 정렬 후 <strong>그리디 알고리즘</strong>으로 풀 수 있을지 고려하기
- 배열의 최솟값이나 최댓값을 이용해야 하는데 시간 복잡도를 O(nlogn)으로 줄여야 한다면 <strong>PrioriryQueue</strong> 이용하기
- 가중치 그래프의 최단거리를 구할때 <strong>다익스트라 알고리즘</strong> 고려하기
- 서로소인 집합인지 아닌지 확인해야 한다면 <strong>Union & Find</strong> 알고리즘 이용하기
